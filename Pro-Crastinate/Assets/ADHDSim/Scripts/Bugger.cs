// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

namespace RMX
{

	public enum Testing {
		Misc, GameCenter, Achievements, Exceptions, GameDataLists, Singletons, Patches

	}

	public class Bugger : ASingleton<Bugger>
	{
		#if DEBUG || true
		public bool beta = true;
		#else
		private static bool _willTest = false;
		#endif
		public bool printToScreen = true;
		public const float maxDisplayTime = 5;

		public List<string> queue = new List<string>();
		public Dictionary<Testing,bool> features = new Dictionary<Testing, bool>()
		{
			{ Testing.Misc 				, true },
			{ Testing.GameCenter		, true },
			{ Testing.Achievements		, true },
			{ Testing.Exceptions		, true },
			{ Testing.Singletons		, false },
			{ Testing.GameDataLists		, true },
			{ Testing.Patches			, true }
		};

		protected override void Awake() {
//			TestAll(true);
			base.Awake ();
		}

		public static bool WillTest(Testing featureToTest) {
			return current.beta && current.features [featureToTest];
		}

		public static string Last {
			get {
				return current.log.message;
			}
		}

		public static DebugLog StartLog(Testing featureToTest, string message) {
			var log = StartLog (featureToTest);
			log.message = message;
			current.log = log;
			return log;
		}

		public static bool WillLog(Testing featureToTest, string message) {
			if (!WillTest (featureToTest))
				return false;
			return StartLog (featureToTest, message).isActive;
		}

		public static DebugLog StartLog(Testing featureToTest) {
			current.log.Start (featureToTest);
			return current.log;
		}


		public void TestAll(bool willTest) {
			foreach (KeyValuePair<Testing,bool> entry in features) {
				features[entry.Key] = willTest;
			}
		}

		public DebugLog log = new DebugLog();

		private bool timesUp {
			get{ 
				return beta && queue.Count > 0 && Time.fixedTime - _startedAt > maxDisplayTime;
			}
		}

		private int timeRemaining {
			get {
				return (int) (maxDisplayTime - (Time.fixedTime - _startedAt));
			}
		}


		void Update() {
			if (timesUp) {
				queue.RemoveAt(0);
				_startedAt = Time.fixedTime;
			}
		}
		private float _startedAt = 0;

		public void AddToQueue(string log) {
			if (queue.Count == 0)
				_startedAt = Time.fixedTime;
			if (!queue.Exists( val =>  {
				return val == log;
			}))
				queue.Add (log);
		}

		void OnGUI () {
			if (beta && printToScreen && queue.Count > 0) {
				var text = timeRemaining + " â€“ " + queue[0];
				GUIStyle style = new GUIStyle ();
//				style.fontSize = 50;
				style.richText = true;
				style.wordWrap = true;
				style.alignment = TextAnchor.LowerLeft;
				style.padding.left = style.padding.right = style.padding.top = style.padding.bottom = 20;
//				style.border
				GUI.Label (new Rect (0, 0, Screen.width, Screen.height), text, style);
			}
		}
		public class DebugLog {
			private string log = "";

			public string message {
				get {
					return log;
				} set {
					if (WillTest(this.feature))
						log = value;
				}
			}

			public Testing feature = Testing.Misc;

			public void Clear() {
				log = "";
			}

			public bool isActive {
				get {
					return WillTest(this.feature);
				}
			}
			public void Start(Testing feature) {
				this.feature = feature;
				this.log = "";
			}

			private string color {
				get {
					switch (this.feature) {
					case Testing.Exceptions:
						return "red";
					case Testing.GameCenter:
						return "yellow";
					case Testing.Patches:
						return "green";
					default:
						return "blue";
					}
				}
			}

			private string ProcessLog() {
				string header = "<color=" + color + ">" + this.feature + ": </color>\n";
				var log = this.message.Replace ("Failed", "<color=red>FAILED</color>");
				log = log.Replace ("succeeded", "<color=green>SUCCEEDED</color>");
				log = log.Replace ("successful", "<color=green>SUCCESSFUL</color>");
				log = log.Replace (" success", "<color=green> SUCCESS</color>");
				return header + log;
			}
			public override string ToString() {
				string log;// = this.log;
				if (isActive && this.log.Length > 0) {
					log = ProcessLog();
					if (current.printToScreen) {
						current.AddToQueue(log);
					}
				} else {
					log = null;
				}
				Clear ();
				return log;
			}
		}
	}


}

